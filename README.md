<a href="https://github.com/JaeSeoKim/badge42"><img src="https://badge42.vercel.app/api/v2/cl4qxms4g001609l49j835g66/project/3075788" alt="joslopez's 42 coRSAir Score" /></a>
<h2>General instructions</h2> <p>For this project, you must use C as the language. The list of allowed functions is as follows:</p> <ul> <li>All functions of <code>&lt;math.h&gt;</code></li> <li>All functions of <code>&lt;string.h&gt;</code></li> <li>The [openssl library]</li> <li>Everything that is permitted in the exercise header.</li> </ul>  <h2>Mandatory Part</h2> <p>Security in [asymmetric cryptography] using [RSA keys] is based on the premise that it is computationally very difficult to factor the two prime factors of a number. "Multiplying two prime numbers p and q to get n" is a simple operation, and its complexity does not increase dramatically as the numbers grow:</p> <p><code>[1736640013 1230300287 = 2136588706409583731]</code></p> <p>In contrast, the [inverse operation], "given a number n obtain its two prime factors", is an operation that becomes computationally infeasible when the numbers involved are large enough.</p> <p>To generate the [key pair], the [RSA algorithm] creates a public and private key using this concept. Simplifying the generation of the keys, the randomly chosen primes p and q are multiplied to create the modulus n that will be used in both the private and public keys. This module n is public but the prime factors p and q are not.</p> <p><code>[? · ? =2136588706409583731]</code></p> <p>If we have two certificates generated in a system whose [random number generator] is weak and therefore in which the entropy is minimum... This may have increase the probability of repetitions of [prime numbers] during different generations, thus it might have been the case in which two modules share the same factor p or q.</p> <p><code>[n1 = p1 · q1] [n2 = p1 · q2]</code></p> <p>Program name: <code>corsair</code></p> <p>Turn in files: <code>*.c</code>, <code>*.h</code></p> <p>External funcs: <code>printf</code>, <code>snprintf</code>, <code>write</code>, <code>read</code>, <code>open</code>, <code>close</code>, <code>malloc</code>, <code>free</code></p> <p>Description: Cryptography block: Vulnerable Ciphers</p> <p>With this information, you will create a tool that:</p> <ul> <li>Reads the public key of these certificates and get the modulus and exponent and then calculates the rest of the necessary data.</li> <li>Constructs the private key from two primes and their product, and from there, gets the [symmetric key] encrypted with it.</li> <li>Decrypts the message!</li> </ul>  <h2>Bonus Part</h2> <p>The evaluation of the bonuses will be done IF AND ONLY IF the [mandatory part] is PERFECT. Otherwise, the bonuses will be totally IGNORED.</p> <p>You can enhance your project with the following features:</p> <ul> <li>Detailed and clear documentation of all the theoretical foundations behind the project.</li> <li>Proprietary implementation of a library or set of functions in C to operate with large integers.</li> <li>Everything that comes to your mind... you will be able to justify everything during the defense.</li> </ul>
